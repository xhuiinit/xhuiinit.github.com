---
layout:     post
title:      "Redis高并发产生超卖现象"
subtitle:   "高并发为什么带来超卖？什么是超卖现象？"
date:       2015-01-29 12:00:00
author:     "pizida"
header-img: "img/post-bg-2015.jpg"
tags:
    - 技术
---



最近在开发一个抢红包的活动时候，由于并发导致了超卖的问题，导致发放的红包过多

# 什么是超卖

首先，它不是股市那个超卖，炒股的朋友可以关闭这个页面了。
超卖就是卖出的商品超过了本来的库存。例如，你举办了一个秒杀活动，只要卖出1台iPhone 100S，但是现在有10个用户抢到了这个iPhone 100S。这个时候你需要卖出10台iPhone 100S。但你又没货，这就超卖了！

# 产生超卖的原因

系统发来了多个并发请求，同时判断当前限制是否超出库存（程序响应时间非常短），都判断出还有一个iPhone 100S，对每个用户都发送，最后超卖。

# 超卖可能带来的后果

1. 经济损失：无法给出10台 iPhone 100S，用户不满，告你欺诈，收到法院传票，赔偿受害者。
2. 信任危机：用户这么难抢到100 台iPhone 100S，你说没有，他们感觉不会再爱。就比如你你买彩票，大奖号码和你的号码一模一样，后来，人家说，号码要错了。
3. 关系紧张：同事关系紧张，领导对你的质疑。
4. 上面三个其实都不重要，最最最最重要的是：年终奖的估值（严肃脸）  

# 真实案例抢红包

* 业务逻辑
	+ 全服务器一起抢红包，发放的红包不固定	
	+ 每个小时发放的金币是固定的100万
	+ 每个整点前5分钟为开抢时间。（进一步加剧短时间内的高并发。。。）
	+ 每个用户只能抢一次
	+ 用户所获得的金币数是不固定的，需要经过一定业务逻辑然后随机金币。（这跟微信红包拼手气还不一样，因为拼手气红包本身已经确定是随机获取，既然逻辑固定，在用户没抢之前已经可以分配好金额入队，所以谁先谁后，完全没有关系。用户实际点击时，只需要判断用户是否获得过红包，没有的话即可发送预先安排好的红包，完全不会有并发情况，那就更没有所谓的超卖。）

# 实际结果

活动上线几个小时候，金币发放1500万，大大超过预期。查询DB数据，发现大量同一时间戳取得的结果（非微秒级别），证明产生了并发。看图

![并发原因](http://7xqfiw.com1.z0.glb.clouddn.com/04140013_NzXS.jpg)

*上图这种情况下，用户A获得了商品，用户B也获得了商品，这就是超卖现象。因为活动中用到了redis，redis本身是单线程的，出现超卖的原因是程序中抢红包的一系列操作应该是一个原子性的行为。每个用户都可以同时写入，redis本身并没有锁，需要自己去设计。好在redis提供了简单的事务控制。*

# 高并发以及超卖现象的解决方案（纵向讨论，非分布式）

1. 活动页面静态化，CDN处理技术
  
	尽量展示使用CDN提供高速反应，选择离用户最近的节点，减少应用服务器压力

2. 过滤用户
	
	这里可以根据自身的业务逻辑和使用场景去设计，因为最终只要100万金币发放，肯定会有用户都抢不到，所以我们可以让部分用户进入活动，展示“红包已经抢完”。可以是单双号限制，等级高低限制，是否充值限制等等。当然也可以计算大概多少人的金币发放达到了100万，然后在这里排队，只允许多少人进来。

3. 乐观锁（乐观锁控制，对实时要求并产生超卖的主要解决手段）

	超卖现象可以使用乐观锁或者悲观锁解决问题，但是悲观锁对于并发性能不友好。这里我们使用redis的乐观锁进行处理。

>乐观锁就是不相信数据会被修改，是一种更加宽松的锁机制。同一个数据所有请求都可以进行修改。每个请求都带一个版本号，如果操作结束和版本号不符，就禁止修改提交。

redis提供了简单的事务处理机制，redis事务没有回滚功能，这必须手动实现； 

事务中的watch就是典型的乐观锁。Redis 通过[MULTI](http://redisdoc.com/transaction/multi.html), [WATCH](http://redisdoc.com/transaction/watch.html), [UNWATCH](http://redisdoc.com/transaction/unwatch.html) , [EXEC](http://redisdoc.com/transaction/exec.html),[DISCARD](http://redisdoc.com/transaction/discard.html)四个命令来实现事务功能。

# 核心代码
 {% highlight ruby %}
 $redis = new redis();

 $result = $redis->connect('localhost', 6379);

 $total = $redis->get("totalkey");

 $can_num = 100;

 if ( $total <$can_num ){ 

  #监控发出去的红包总数  $redis->watch("totalkey");

  #事务的开始
  $redis->multi();

  #设置被监控的key，如果在multi和exec之间对watch的key进行修改，
  #那么exec将会返回nil
  $redis->set("totalkey",++$total);

  #提交事务。如果这时A和B都是限制范围内进来，A先监控了totalkey，然后提交。
  #那么B在这一步将会提交失败。因为总量已被修改
  $result = $redis->exec();
  if (!$result){
    return array('msg'=>'没有抢到红包哦，继续努力!','count'=>0);
  }else{
    $count = mt_rand(1,1000);#在0到1000之间随机金币，逻辑自行丰富
    return array('msg'=>'抢红包成功！','count'=>$count);
  }

}
{% endhighlight %}

预期：乐观锁控制后，金币已经控制在100万多一点。属于正常范围内

# 总结
1. 抢红包类活动（秒杀，1元购等等）当然可以通过**`队列+延迟`**处理方式去解决，这是最完美的解决方案，但是因为业务逻辑，必须将金币实时发给用，所以可以通过悲观锁或乐观锁去解决问题。

2. watch是redis中乐观锁的典型应用，它结合multi，exec等操作，可以将一系列的redis命令打包，然后发送给服务器。但是记住一系列的命令中又一个命令操作失败，redis是不会回滚的，其他命令照样可以执行成功。

关于watch需要记住的：

	1. 如果在事务块中所watch的key没有被当前请求修改或者被其他请求修改，exec都将返回失败；

	2. 如果你watch了多个key，那么事务块中至少要有一个key被修改，否则exec也返回失败；

